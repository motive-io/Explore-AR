// Copyright (c) 2018 RocketChicken Interactive Inc.

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.18052
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using Motive.Core.Diagnostics;
using Motive.Unity.Utilities;
using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using UnityEngine;

namespace Motive.Unity.Diagnostics
{
    /// <summary>
    /// Manages Motive logging through Unity.
    /// </summary>
	public class UnityLoggingControl : MonoBehaviour, ILoggingControlDelegate
	{
        public LogLevel DebugLevel = LogLevel.Debug;
        public LogLevel ReleaseLevel = LogLevel.Warning;

        public LogLevel Level { get; private set; }
        
        public bool IncludeTimestamps = false;
		public bool IncludeThreadId = false;
		public bool EnableAllLoggers = true;
		public bool LogToFile = false;
		public string LogFilePath = "logs";

        const string g_timestampFormat = "yyyy-MM-dd HH:mm:ss.fff";

		public string[] EnabledLoggers;
		//public string[] RegisteredLoggers;

		StreamWriter m_logFileWriter;

		void Awake()
		{
			g_instance = this;
			HasInstance = true;
            LoggingControl.Instance.Delegate = this;

            Level = BuildSettings.IsDebug ? DebugLevel : ReleaseLevel;

            UnityEngine.Application.logMessageReceived += HandleUnityLogging;

            if (LogToFile)
			{
				var path = Path.Combine(UnityEngine.Application.persistentDataPath, LogFilePath);

				Directory.CreateDirectory(path);

				var filename = Path.Combine(path, string.Format("log-{0}.txt", DateTime.Now.ToString("yyyy-MM-dd HH-mm-ss")));
				m_logFileWriter = new StreamWriter(File.Open(filename, FileMode.Append, FileAccess.Write, FileShare.Read));
			}
		}

		public static bool HasInstance { get; private set; }

        static UnityLoggingControl g_instance;

        public static UnityLoggingControl Instance { get { return g_instance; } }

        int CurrentThreadId
        {
            get
            {
#if WINDOWS_UWP
                return System.Threading.Tasks.Task.CurrentId.GetValueOrDefault();
#else
                return Thread.CurrentThread.ManagedThreadId;
#endif
            }
        }

        string FormatMessage(string componentName, LogLevel level, string message, params object[] args)
        {
            StringBuilder builder = new StringBuilder();

			bool timestamp = IncludeTimestamps;
            bool tid = IncludeThreadId;

			if (timestamp) {
				builder.Append(DateTime.Now.ToString(g_timestampFormat));
				builder.Append(" ");
			}

			if (tid) {
				builder.AppendFormat("{0} ", CurrentThreadId);
			}

            if (!string.IsNullOrEmpty(componentName))
            {
                builder.AppendFormat("{0} [{1}] ", level.ToString().ToUpper(), componentName);
			}

			if (args != null) {
				builder.AppendFormat(message, args);
			} else {
				builder.Append(message);
			}

			return builder.ToString();
		}

        void HandleUnityLogging(string logString, string stackTrace, LogType type)
        {
            // This method only logs to file--sending it through the normal log
            // path would send it back here.
            if (!LogToFile)
            {
                return;
            }

            LogLevel level;

            switch (type)
            {
                case LogType.Assert:
                case LogType.Error:
                case LogType.Exception:
                    level = LogLevel.Error;
                    break;
                case LogType.Warning:
                    level = LogLevel.Warning;
                    break;
                case LogType.Log:
                default:
                    level = LogLevel.Debug;
                    break;
            }

            if (level > Level)
            {
                return;
            }

            var msg = string.Format("{0}\n{1}", logString, stackTrace);

            lock (m_logFileWriter)
            {
                m_logFileWriter.WriteLine(msg);
                m_logFileWriter.Flush();
            }
        }

        public void LogMessage(string componentName, LogLevel level, string message, params object[] args)
        {
            if (!IsLoggerEnabled(componentName, level))
            {
                return;
            }

            var formattedMsg = FormatMessage(componentName, level, message, args);
            
            switch (level)
            {
                case LogLevel.Info:
                case LogLevel.Verbose:
                case LogLevel.Debug:
                    UnityEngine.Debug.Log(formattedMsg);
                    break;
                case LogLevel.Warning:
                    UnityEngine.Debug.LogWarning(formattedMsg);
                    break;
                case LogLevel.Error:
                    UnityEngine.Debug.LogError(formattedMsg);
                    break;
            }

            /* Now picked up by Unity Logger above
			if (LogToFile && m_logFileWriter != null)
			{
				lock (m_logFileWriter)
				{
					m_logFileWriter.WriteLine(formattedMsg);
					m_logFileWriter.Flush();
				}
			}*/
        }

        public void LogException(Exception x)
        {
            UnityEngine.Debug.LogException(x);

			if (LogToFile && m_logFileWriter != null)
			{
				lock (m_logFileWriter)
				{
					m_logFileWriter.WriteLine(x.ToString());
				}
			}
		}

        public bool IsLoggerEnabled(string loggerName, LogLevel level)
        {
            return
                level <= Level &&
                (EnableAllLoggers ||
                (EnabledLoggers != null && EnabledLoggers.Contains(loggerName)));
        }
    }
}

